---
// Subtle network topology background - minimal and refined
// Acts as a background flavor element without overwhelming content
---

<div class="network-background-container">
  <canvas id="networkCanvas" class="network-canvas"></canvas>
</div>

<style>
  .network-background-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    background: linear-gradient(135deg, #0a0e27 0%, #0f1629 50%, #0d1b2a 100%);
    overflow: hidden;
  }

  .network-canvas {
    display: block;
    width: 100%;
    height: 100%;
  }
</style>

<script>
  interface NetworkNode {
    x: number;
    y: number;
    radius: number;
    pulse: number;
  }

  interface Packet {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    maxLife: number;
  }

  class SubtleNetworkBackground {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D | null;
    nodes: NetworkNode[] = [];
    packets: Packet[] = [];
    animationId: number | null = null;
    time = 0;

    constructor(canvasId: string) {
      const canvas = document.getElementById(canvasId) as HTMLCanvasElement;
      if (!canvas) return;

      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.resizeCanvas();
      this.initializeNodes();
      this.startAnimation();
      
      window.addEventListener('resize', () => this.resizeCanvas());
    }

    resizeCanvas() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }

    initializeNodes() {
      // Create a minimal set of subtle nodes distributed across the canvas
      const w = this.canvas.width;
      const h = this.canvas.height;

      this.nodes = [
        { x: w * 0.2, y: h * 0.3, radius: 2, pulse: 0 },
        { x: w * 0.8, y: h * 0.3, radius: 2, pulse: 0.3 },
        { x: w * 0.5, y: h * 0.5, radius: 3, pulse: 0.15 },
        { x: w * 0.1, y: h * 0.7, radius: 2, pulse: 0.45 },
        { x: w * 0.9, y: h * 0.7, radius: 2, pulse: 0.6 },
        { x: w * 0.35, y: h * 0.15, radius: 1.5, pulse: 0.2 },
        { x: w * 0.65, y: h * 0.85, radius: 1.5, pulse: 0.5 }
      ];
    }

    spawnPacket() {
      // Rarely spawn packets
      if (Math.random() > 0.98) {
        const node = this.nodes[Math.floor(Math.random() * this.nodes.length)];
        const angle = Math.random() * Math.PI * 2;
        const speed = 0.5 + Math.random() * 1;
        
        this.packets.push({
          x: node.x,
          y: node.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 1,
          maxLife: 1
        });
      }
    }

    drawNode(node: NetworkNode) {
      if (!this.ctx) return;

      const pulse = 0.5 + Math.sin(this.time * 0.002 + node.pulse) * 0.3;
      const opacity = 0.4 * pulse;

      this.ctx.fillStyle = `rgba(79, 172, 254, ${opacity})`;
      this.ctx.beginPath();
      this.ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
      this.ctx.fill();

      // Subtle glow
      this.ctx.strokeStyle = `rgba(79, 172, 254, ${opacity * 0.3})`;
      this.ctx.lineWidth = 1;
      this.ctx.beginPath();
      this.ctx.arc(node.x, node.y, node.radius + 4, 0, Math.PI * 2);
      this.ctx.stroke();
    }

    drawConnection(node1: NetworkNode, node2: NetworkNode) {
      if (!this.ctx) return;

      const distance = Math.hypot(node2.x - node1.x, node2.y - node1.y);
      const maxDist = 400;

      if (distance > maxDist) return;

      const opacity = (1 - distance / maxDist) * 0.1;

      this.ctx.strokeStyle = `rgba(79, 172, 254, ${opacity})`;
      this.ctx.lineWidth = 0.5;
      this.ctx.beginPath();
      this.ctx.moveTo(node1.x, node1.y);
      this.ctx.lineTo(node2.x, node2.y);
      this.ctx.stroke();
    }

    drawPackets() {
      if (!this.ctx) return;

      this.packets = this.packets.filter(p => {
        p.life -= 0.02;
        p.x += p.vx;
        p.y += p.vy;

        if (p.life > 0) {
          const opacity = p.life * 0.4;
          
          // Draw packet
          this.ctx!.shadowColor = 'rgba(79, 172, 254, 0.5)';
          this.ctx!.shadowBlur = 4;
          this.ctx!.fillStyle = `rgba(79, 172, 254, ${opacity})`;
          this.ctx!.beginPath();
          this.ctx!.arc(p.x, p.y, 1.5, 0, Math.PI * 2);
          this.ctx!.fill();
          
          this.ctx!.shadowColor = 'transparent';
          return true;
        }
        return false;
      });
    }

    animate = () => {
      if (!this.ctx) return;

      this.time++;

      // Very subtle clear - let trails fade naturally
      this.ctx.fillStyle = 'rgba(10, 14, 39, 0.02)';
      this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

      // Draw connections
      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          this.drawConnection(this.nodes[i], this.nodes[j]);
        }
      }

      // Draw nodes
      this.nodes.forEach(node => this.drawNode(node));

      // Draw packets
      this.spawnPacket();
      this.drawPackets();

      this.animationId = requestAnimationFrame(this.animate);
    };

    startAnimation() {
      this.animate();
    }

    stop() {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new SubtleNetworkBackground('networkCanvas');
    });
  } else {
    new SubtleNetworkBackground('networkCanvas');
  }
</script>
